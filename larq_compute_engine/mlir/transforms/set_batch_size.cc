#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Pass/Pass.h"

// This pass will set the batch dimension of all inputs of the outermost
// function to 1, leaving it to shape inference to do the rest.

namespace mlir {

namespace {

mlir::Type SetBatchSize(mlir::Type type) {
  auto tensor_type = type.dyn_cast<mlir::TensorType>();
  if (tensor_type && tensor_type.hasRank()) {
    auto shape = tensor_type.getShape();
    if (shape.size() > 0 && shape[0] == ShapedType::kDynamicSize) {
      // Create a new shape but set the first dimension to 1
      llvm::SmallVector<int64_t, 4> shape_new(shape.begin(), shape.end());
      shape_new[0] = 1;

      return tensor_type.clone(shape_new);
    }
  }
  return nullptr;
}

struct SetBatchSizePass
    : public PassWrapper<SetBatchSizePass, OperationPass<mlir::func::FuncOp>> {
  llvm::StringRef getArgument() const final { return "mlir-setbatchsize"; }
  llvm::StringRef getDescription() const final { return "Set batch size to 1"; }
  void runOnOperation() override {
    mlir::func::FuncOp func = getOperation();

    // We have to edit both the function signature (mlir::Type) *and* the
    // function arguments (mlir::Value)

    // mlir::FunctionType is a TableGen-autogenerated MLIR type
    mlir::FunctionType signature = func.getFunctionType();

    // Create a mutable copy of the input types, since getInputs returns an
    // immutable llvm::ArrayRef<mlir::Type>
    std::vector<mlir::Type> signature_inputs(signature.getInputs());

    for (auto& input_type : signature_inputs) {
      auto new_type = SetBatchSize(input_type);
      if (new_type) input_type = new_type;
    }

    auto signature_new = mlir::FunctionType::get(
        signature.getContext(), signature_inputs, signature.getResults());
    // Set the new signature
    func.setFunctionTypeAttr(mlir::TypeAttr::get(signature_new));

    // Now apply the same change to the mlir::Value objects
    for (mlir::BlockArgument arg : func.getArguments()) {
      // mlir::BlockArgument is a sublcass of mlir::Value
      auto new_type = SetBatchSize(arg.getType());
      if (new_type) arg.setType(new_type);
    }
  }
};

}  // namespace

// Creates an instance of the ZeroPointCompatibility pass.
std::unique_ptr<OperationPass<mlir::func::FuncOp>> CreateSetBatchSizePass() {
  return std::make_unique<SetBatchSizePass>();
}

static PassRegistration<SetBatchSizePass> pass;

}  // namespace mlir
