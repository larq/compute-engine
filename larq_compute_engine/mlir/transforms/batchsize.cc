#include "mlir/Pass/Pass.h"

// This pass will set the batch dimension of all inputs of the outermost
// function to 1, leaving it to shape inference to do the rest.

namespace mlir {

namespace {

mlir::Type SetBatchSize(mlir::Type type) {
  auto tensor_type = type.dyn_cast<mlir::TensorType>();
  if (tensor_type && tensor_type.hasRank()) {
    auto shape = tensor_type.getShape();
    if (shape.size() > 0 && shape[0] == ShapedType::kDynamicSize) {
      // Create a new shape but set the first dimension to 1
      llvm::SmallVector<int64_t, 4> shape_new(shape.begin(), shape.end());
      shape_new[0] = 1;

      return tensor_type.clone(shape_new);
    }
  }
  return nullptr;
}

struct SetBatchSizePass : public PassWrapper<SetBatchSizePass, FunctionPass> {
  void runOnFunction() override {
    FuncOp func = getFunction();

    // We have to edit both the function signature (mlir::Type) *and* the
    // function arguments (mlir::Value)

    // mlir::FunctionType is a TableGen-autogenerated MLIR type
    mlir::FunctionType signature = func.getType();

    // Create a mutable copy of the input types, since getInputs returns an
    // immutable llvm::ArrayRef<mlir::Type>
    std::vector<mlir::Type> signature_inputs(signature.getInputs());

    for (auto& input_type : signature_inputs) {
      auto new_type = SetBatchSize(input_type);
      if (new_type) input_type = new_type;
    }

    auto signature_new = mlir::FunctionType::get(
        signature.getContext(), signature_inputs, signature.getResults());
    // Set the new signature
    func.typeAttr(mlir::TypeAttr::get(signature_new));

    // Now apply the same change to the mlir::Value objects
    for (mlir::BlockArgument arg : func.getArguments()) {
      // mlir::BlockArgument is a sublcass of mlir::Value
      auto new_type = SetBatchSize(arg.getType());
      if (new_type) arg.setType(new_type);
    }
  }
};

}  // namespace

// Creates an instance of the ZeroPointCompatibility pass.
std::unique_ptr<OperationPass<FuncOp>> CreateSetBatchSizePass() {
  return std::make_unique<SetBatchSizePass>();
}

static PassRegistration<SetBatchSizePass> pass("mlir-setbatchsize",
                                               "Set batch size to 0");

}  // namespace mlir
